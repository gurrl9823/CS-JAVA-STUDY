### 세그멘테이션과 페이징의 차이점은 무엇인가요?
(1) 페이징  
메모리를 관리 기법 중 불연속 메모리 관리 기법입니다. 페이징은 외부단편화와 압축 작업을 해결하기 위한 방법으로, 메모리는 Frame이라는 고정크기로 분할되고, 프로세스는 Page라는 고정크기로 분할됩니다.    
페이지와 프레임을 대응시키는 page mapping과 paging table을 생성해야합니다.
페이징을 사용하면 외부 단편화를 해결한다는 장점이 있지만 내부단편화는 여전히 존재합니다.

(2) 세그멘테이션
세그멘테이션은 페이징과는 달리 크기가 서로 다른 논리적 단위인 세그먼트로 메모리를 분리합니다. 세그멘테이션을 사용하면 세그먼트들이 메모리에 할당되고 해제되는 과정에서 외부단편화가 발생합니다. 하지만 세그먼트는 메모리를 의미 단위로 나누기 때문에 보호와 공유에서 효율적입니다.  

(3) 차이점
- 페이징은 고정된 크기를가짐  
- 세그멘테이션은 가변 크기를 가짐
- 페이징은 내부 단편화 발생가능, 세그멘테이션은 외부 단편화 발생 가능

#### 위 두 가지의 장단점   
페이징 
- 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고, 물리 메모리의 남는 프레임에 적절히 배치되기 때문에 외부 단편화가 생기지 않는다.   


세그멘이션 
- 내부 단편화 문제가 해소된다.
- 보호와 공유 기능을 수행할 수 있다. 프로그램의 중요한 부분과 중요하지 않은 부분을 분리하여 저장할 수 있고, 같은 코드 영역은 한 번에 저장할 수 있다.  

#### 페이지와 프레임의 차이에 대해 설명해 주세요.
프레임은 물리 메모리를 일정한 크기로 나눈 블록이고, 페이지는 가상 메모리를 일정한 크기로 나눈 블록이다


#### 내부 단편화와, 외부 단편화에 대해 설명해 주세요.
1. 외부단편화란 총 메모리 공간은 충분하지만 실제로 할당할수 없는 경우
(메모리 할당 및 해제 작업의 반복으로 작은 메모리가 중간 중간 존재할 수 있다. 이렇게 사용하지 않는 메모리가 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황이다.)
2. 내부단편화란 프로세스가 사용하는 메모리 공간 중 남는 부분이 발생하는 현상
(메모장을 켯을 때 os가 4kb를 할당했지만 메모장은 1kb를 사용할 때 불필요하게 남은 공간을 의미)


#### 페이지에서 실제 주소를 어떻게 가져올 수 있는지 설명해 주세요.
MMU(Memory Management Unit): CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소 값으로 변환해주는 하드웨어 장치
즉, CPU는 가상 메모리를 다루고, 가상 메모리의 가상 주소에 접근시 MMU하드웨어를 통해 물리 주소로 변환되어 물리 메모리에 접근한다.  


### 페이지 크기에 대한 trade-off를 설명해주세요.
- 페이지 단위를 작게하면 내부 단편화(Internal fragmentation)해결할 수 있지만 (페이지에 공간을 할당한 후, 남는 공간이 적어지기 때문에) 그 만큼, 페이지 수와 페이지 테이블이 증가 해 page mapping 과정이 증가하므로 서로 trade off문제가 발생 -> 현재 트랜드는 페이지 크기를 크게 해서 시간보다 공간을 쓰는 것이 더 효율적이라고 판단함
- 페이지크기가 작아지면 테이블이 커지고, 입출력 오버헤드가 발생 확률이 올라가고 캐쉬성능이 높아진다
- 페이지 크기가 커지면 테이블이 커지고 오버헤드가 작아지며 캐쉬성능이 떨어진다.

#### 페이지 크기가 커지면 페이지 폴트가 더 많이 발생하는지?
페이지 크기가 커지면 하나의 페이지가 비슷한 내용을 포괄하므로 참조 지역성 효과가 줄어들면서 페이지폴트 발생률이 올라간다. 가상 메모리 기법은 메모리 폴트 발생율을 줄여 스래싱을 방지해야합니다. 하지만 무조건 적으로 발생하지는 않지만 실행햐야하는 프로세스가 적어지면 메모리 할당이 바로바로 되기 때문에 메모리 크기가 커질수 있다.

### TLB는 무엇인가요?
page table는 메인 메모리에 존재하는데 데이터를 얻으려면 cpu는 메인 메모리에 최소 2을 접근해야하는 문제가 있어 접근 방법을 줄이고자 나온게 tlb입니다. 하드웨어적으로 지원하여 page table의 임시저장 cache 역할을 합니다.
#### TLB를 쓰면 왜 빨라지나요?
CPU에서 나온 정보를 가지고 TLB를 탐색하고, 있다면 바로 물리 주소에 접근하고, 없다면 page table로 들어간다. 이렇게 하면 메모리에 접근하는 일이 없으므로 주소 변환이 빠르게 수행 됩니다
#### MMU가 무엇인가요?
가상 메모리를 실제 물리 메모리로 변환 해주는 장치로 CPU요청이 들어오면 TLB에 원하는 변환 정보를 제일 먼저 확인 하고 없다면 페이지 테이블에 가게 된다
#### TLB와 MMU는 어디에 위치해 있나요?
TLB는 MMU안에 위치에 해 있으며 MMU는 CPU안에 들어가 있다.

---

### Page Fault란

- page fault가 발생하였을때, 이를 처리하는 과정을 설명해주세요.
- 페이지 교체 알고리즘엔 어떤 것들이 있나요?

### 페이지 교체 알고리즘엔 어떤 것들이 있나요?

- MFU MRU 의 가치?
- Clock / Second chance
- LRU 알고리즘은 어떤 특성을 이용한 알고리즘이라고 할 수 있을까요?
- LRU 알고리즘을 구현한다면, 어떻게 구현할 수 있을까요?

---

## 메모리의 연속할당 방식 세 가지를 설명해주세요. (first-fit, best-fit, worst-fit)

- worst-fit이 왜 사용될까요?
- buddy-system / slab Memory Allocator이란
- 성능이 가장 좋은 알고리즘은 무엇일까요?
- 물리메모리/가상메모리/캐시메모리 설명해주세요

### 가상 메모리란 무엇인가요?

- 가상 메모리가 가능한 이유가 무엇일까요?
- Secondary Memory에서 page를 가져오는 영역 이름
- ddalcls
- Page Fault가 발생했을 때, 어떻게 처리하는지 설명해 주세요.
- 페이지 크기에 대한 Trade-Off를 설명해 주세요.
- 페이지 크기가 커지면, 페이지 폴트가 더 많이 발생한다고 할 수 있나요?

### 캐시 메모리 및 메모리 계층성에 대해 설명해 주세요.

- Cache는 어디있나?
- L1, L2 캐시
- 캐시에 올라오는 데이터는 어떻게 관리가 되나? cache Line
- 캐시 메모리는 어디에 위치해 있나요?
- L1, L2 캐시에 대해 설명해 주세요.
- 캐시에 올라오는 데이터는 어떻게 관리되나요?
- 캐시간의 동기화는 어떻게 이루어지나요?
- 캐시 메모리의 Mapping 방식에 대해 설명해 주세요.
- 캐시의 지역성에 대해 설명해 주세요.
- 캐시의 지역성을 기반으로, 이차원 배열을 가로/세로로 탐색했을 때의 성능 차이에 대해 설명해 주세요.

### MMU

- OS에서 프로세스는 CPU와 메모리 사이에 MMU(Memory Management Unit)를 두어서 다른 프로세스에 접근할하지 못합니다. 그러나 GDB와 같은 디버거의 경우 다른 프로세스에 접근하여 절대적 메모리 주소와 값을 읽어올 수 있습니다. 어떻게 가능한지 동작 방식에 대해서 설명하세요.

---

### 파일 시스템

● File System에 대해 설명해 주세요.
 - 파일 시스템은 "운영체제가 파일을 관리하는 방법" 입니다. 파일의 생성, 삭제, 이동, 복사, 검색, 보안 설정 등  다양한 기능을 제공합니다.
파일 시스템의 종류는 다양합니다. 대표적으로 FAT, NTFS, ext2, ext3, ext4 등이 있지요. 운영체제가 윈도우냐 리눅스냐 macOS냐 에 따라서 사용하는 파일시스템이 조금씩 다릅니다. 여러종류가 있지만 위에서 말한 파일의 생성, 삭제, 이동, 복사, 검색, 보안 설정 등을 어떻게 하는지가 조금씩 다를 뿐이지 역할은 모두 같습니다.

● i-Node에 대해 설명해 주세요.
 - i-node는 전통적인 유닉스 계통 파일 시스템에서 사용하는 자료 구조입니다.
Inode를 통해 실제 데이터에 접근하게 됩니다. 그래서 모든 파일들은 각자 고유의 Inode 값을 가지고 있습니다.

● File Descriptor 에 대해 설명해 주세요.
 - 파일 디스크립터는 운영 체제가 파일을 다루기 위해 사용하는 일종의 포인터로, 파일을 열거나 닫고, 읽기나 쓰기 등 파일 작업을 수행할 때 사용됩니다.

● 표준 입력(STDIN), 표준 출력(STDOUT), 표준 에러(STDERR)
어떤 프로세스든 기본적으로 할당되는 디스크립터 입니다. 
stdin(Standard Input, 표준 입력) : 키보드나 파일 등으로부터 데이터를 읽어들일 때 사용됩니다.\
stdin(Standard Input, 표준 출력) : 프로그램에서 출력한 결과를 화면이나 파일에 쓸 때 사용됩니다.
stderr(Standard Error, 표준 에러) : 프로그램 실행 중 오류가 발생했을 때 오류 메시지를 출력하는데 사용됩니다.


------------


파일 시스템을 알아보기에 앞서 먼저 이것부터 보겠습니다.

![image](https://user-images.githubusercontent.com/21374239/229512804-fd569d4e-9681-494f-8f77-9fb09e3b83bc.png)

"모든 것이 파일이다" 라는 개념입니다. 실제로 리눅스에서는 모든 것을 파일로 보고 있습니다.


리눅스 파일 종류

1. 일반 파일 : 텍스트파일, 실행파일, 이미지파일 등 대부분의 파일

2. 디렉토리 파일 : 디렉토리도 파일로 취급

3. 링크 파일 : 원본파일을 다른 파일명으로 지정한 것으로 윈도우의 바로가기와 같은 개념. 심볼릭 링크, 하드링크가 있음.

4. 장치 파일 : 하드디스크, 마우스, 모니터, 스피커 등과 같은 장치들도 파일로 취급

5. 파이프, 소켓 파일 등등

 

이처럼 여러가지를 모두 파일로 인식하고 관리합니다.

 
 

파일 시스템이란?
![image](https://user-images.githubusercontent.com/21374239/229512879-1ff3b5ce-370f-4ccb-9fbb-c20e42958f86.png)

파일 시스템은 "운영체제가 파일을 관리하는 방법" 입니다. 파일의 생성, 삭제, 이동, 복사, 검색, 보안 설정 등  다양한 기능을 제공합니다.

파일 시스템의 종류는 다양합니다. 대표적으로 FAT, NTFS, ext2, ext3, ext4 등이 있지요. 운영체제가 윈도우냐 리눅스냐 macOS냐 에 따라서 사용하는 파일시스템이 조금씩 다릅니다. 여러종류가 있지만 위에서 말한 파일의 생성, 삭제, 이동, 복사, 검색, 보안 설정 등을 어떻게! 하는지가 조금씩 다를 뿐이지 역할은 모두 같습니다.

 유닉스계열의 파일 시스템의 구조를 한 번 볼까요?
![image](https://user-images.githubusercontent.com/21374239/229512920-4983f5e5-fc76-4a09-90d5-eb8bf3496c5e.png)

유닉스계열의 파일 시스템은 크게 4가지 블록으로 구성되어 있습니다.
Boot block : 부팅에 필요한 파일을 가지고 있습니다. 어떤 파일 시스템이라도 가장 먼저 등장하는 블록입니다.
Super block : 파일 시스템에 대한 전체적인 정보를 가지고 있습니다. 전체적인 정보란 비어있는 블록은 무엇이고 사용중인 블록은 무엇이고, 어디부터 어디까지가 Inode list 인지, Data block 인지에 대한 정보입니다.
Inode list : 모든 Inode 파일을 저장하고 있습니다. Inode 파일이라는 것은 실제 파일들에 대한 정보를 가지고 있는 meta data 입니다. 소유자, 실제 파일 데이터 블록 사이즈, 실제 파일 데이터 블록 위치 등의 정보입니다.
Data block : 실제 데이터가 저장되어 있습니다. 데이터는 블록형태로 저장되어 있는데 블록당 사이즈가 보통 4KB 라고 합니다.

i-node는 전통적인 유닉스 계통 파일 시스템에서 사용하는 자료 구조입니다.
Inode를 통해 실제 데이터에 접근하게 됩니다. 그래서 모든 파일들은 각자 고유의 Inode 값을 가지고 있습니다.

![image](https://user-images.githubusercontent.com/21374239/229512980-62ec7df7-a669-42c7-a22c-f9749a0779c4.png)

ls -i 명령어로 파일들의 i-node 값을 확인 할 수 있습니다.

 

 
파일 시스템이 파일을 관리하는 방법이라면, 파일을 사용하는 방법은 무엇이 있을까요?
바로 유닉스계열의 운영체제가 사용하는 file descriptor, 윈도우에서는 이와 비슷한 file handle 가 있습니다.

file descriptor에 대해서 알아볼까요?

파일 디스크립터는 운영 체제가 파일을 다루기 위해 사용하는 일종의 포인터로, 파일을 열거나 닫고, 읽기나 쓰기 등 파일 작업을 수행할 때 사용됩니다.

![image](https://user-images.githubusercontent.com/21374239/229513054-00577cfd-dee3-465b-bbdf-9ad437590402.png)

file descriptor table은 프로세스 당 한개씩 존재하고 file descriptor는 여러개가 있습니다.

 
예를 들어서 youtube 프로세스가 여러 파일을 사용하려고 합니다. 그 때 사용하는 file descriptor 는 접근하려는 파일에 따라서
인터넷 연결 소켓 디스크립터
동영상 파일 디스크립터
오디오 디바이스 디스크립터
키보드, 마우스 디바이스 디스크립터
등이 있습니다. 

youtube 프로세스가 사용하는 file descriptor에서 3번이 동영상 파일 디스크립터라면 이것을 통해 동영상 파일을 열게 됩니다. 열려있는 파일에 대한 정보가 들어있는 open file table은 모든 프로세스가 공용으로 사용합니다.

 
그림에서 fd 0, 1, 2 가 각각 stdin, stdout, stderr 이라고 써져 있죠? 이것은 어떤 프로세스든 기본적으로 할당되는 디스크립터 입니다. 
stdin(Standard Input, 표준 입력) : 키보드나 파일 등으로부터 데이터를 읽어들일 때 사용됩니다.
stdin(Standard Input, 표준 출력) : 프로그램에서 출력한 결과를 화면이나 파일에 쓸 때 사용됩니다.
stderr(Standard Error, 표준 에러) : 프로그램 실행 중 오류가 발생했을 때 오류 메시지를 출력하는데 사용됩니다.

예를 들어서, 사용자로부터 두 수를 입력받아서 더한 결과를 출력하는 프로그램이 있을 때 사용자로부터 입력을 받기 위해서는 stdin을 사용해야 하며, 결과를 출력하기 위해서는 stdout을 사용해야 합니다. 또한, 입력값이 잘못된 경우 오류 메시지를 출력해야 하는데, 이때는 stderr을 사용합니다.

실제로 한번 볼까요?
![image](https://user-images.githubusercontent.com/21374239/229513094-1294dc8f-8d95-4ed6-ae8c-b993ebac771f.png)

리눅스 환경에서 ps -ef 명령어로 현재 동작하고 있는 프로세스를 확인할 수 있습니다. e는 모든 프로세스, f는 자세히를 의미하는 옵션입니다. ps -ef 만 치면 너무 많이 나와서 위의 그림에서는 | grep sshd 를 추가로 입력해서 sshd가 들어가는 프로세스만 출력하였습니다. 맨 윈쪽이 user ID 이고 두번째가 Process ID 입니다. PID가 2633인 프로세스의 file descroptor를 볼까요?

![image](https://user-images.githubusercontent.com/21374239/229513129-c9534a1d-561c-4a2e-9169-579d60a8e14d.png)
sudo ls -trn /proc/[PID]/fd 명령어로 확인할 수 있습니다. 소켓, 파이프 등을 사용하고 있네요!


파일 디스크립터를 통해 확인한 open file table에는 파일에 대한 파일 상태, 파일 위치, 파일 권한 등과 함께 inode 정보도 들어있습니다. 위에서 언급했었던 inode가 여기서도 나오네요! 그래서 이 inode 정보를 통해 실제 파일의 데이터 블록에 접근하게 됩니다.
