## 임계구역 문제가 무엇이고 어떻게 해결하는지 설명하시오.
  ### Q) 세마포어란?
  - 답변 내용
     #### Q-1) 세마포어의 단점
     - 답변 내용
     #### Q-2) 세마포어의 단점을 해결한 방법
     - 답변 내용

---
## 인터럽트는 무엇이고, 어떻게 처리하나요?
인터럽트는 하드웨어나 소프트웨어에서 발생할 수 있으며, 실행 중인 작업을 중단하고 운영체제에게 제어권을 넘기는 신호입니다. 운영체제는 인터럽트를 처리하기 위해 인터럽트 벡터를 통해 적절한 핸들러 함수를 호출하며, 해당 작업을 수행한 뒤 인터럽트가 발생하기 전의 작업으로 복귀합니다. 

#### Polling 방식에 대해 설명해 주세요

Polling 방식은 주기적으로 디바이스나 시스템 상태를 확인하는 방식으로, 프로그램이 무한 루프를 돌며 확인합니다. 디바이스나 시스템 상태가 변경될 때까지 루프가 계속 실행되므로 리소스 낭비가 발생할 수 있습니다.
이를 보완하여 long polling, web socket, WebSocket Handshake와 같은 방식이 나오게 되었습니다.

#### HW / SW 인터럽트에 대해 설명해 주세요

HW인터럽트는 하드웨어 장치에서 발생하는 인터럽트입니다. 예를 들어 마우스나 키보드가 눌릴 때 발생합니다. 
반면 SW인터럽트는 소프트웨어에서 발생하는 인터럽트입니다. 예를 들어 프로그램이나 서비스 요청에 의해서 발생합니다. 

#### 한컴오피스 '한글'을 클릭 후 빈 화면의 커서가 깜빡이고 있다. 이때 hello world를 작성하면 컴퓨터 내부에서 어떤 일이 발생하는가?

운영체제는 해당 프로그램을 실행시키기 위해 프로세스를 생성합니다. 
이때 프로세스 내부에서 hello world를 작성하면, 운영체제는 해당 프로세스의 메모리 공간에 데이터를 쓰는 작업을 수행하고, 화면 출력 등의 작업은 디바이스 드라이버를 통해 실행합니다.
디바이스 드라이버는 하드웨어와 상호작용하여 실제 출력을 담당합니다.

#### DMA이란

DMA (Direct Memory Access)는 CPU의 개입 없이 입출력 장치가 직접 메모리에 데이터를 읽고 쓰는 기술입니다. CPU가 인터럽트를 처리하거나 다른 작업을 수행하는 동안에도 입출력이 가능하므로 시스템의 전체 성능을 향상할 수 있습니다.


#### 마우스로 한글 바로가기를 클릭했을 때 컴퓨터에서 일어나는 모든 일에 대해서 설명하세요

Interrupt: 마우스 클릭은 입력 장치에서 인터럽트를 발생시킵니다. CPU는 이 인터럽트를 인지하고 현재 실행중인 작업을 일시 중단하고 인터럽트 처리를 시작합니다.

Process Scheduling: OS는 마우스 클릭 이벤트를 인지하고 해당 이벤트에 대한 처리를 위해 적절한 프로세스를 스케줄링합니다. 이를 위해 OS는 CPU의 사용 순서를 결정하고, 다른 프로세스들의 실행을 일시 중단하여 클릭 이벤트 처리에 필요한 리소스를 할당합니다.

Disk Scheduling: 한글 바로가기 클릭 시 실행되는 프로그램이 저장된 디스크의 데이터를 읽습니다.

---
## 데드락에 대해 설명해주세요.
- 여러 프로세스가 서로 다른 프로세스의 작업이 끝나기를 기다리다가 아무도 작업을 진행하지 못하는 상태를 데드락이라고 합니다.

- 데드락은 일상생활에서도 일어날 수 있습니다. 대표적인 예로는 복잡한 퇴근길에 교차로에서 꼬리물기를 해서 도로가 마비되는 상황입니다. 

### 데드락이 동작하기 위한 4가지 조건에 대해 설명해주세요.
- 1. 상호배제 : 어떤 프로세스가 한 리소스를 점유했다면 그 리소스는 다른 프로세스에게 공유가 되면 안됩니다. 
- 2. 비선점 : 프로세스 A가 리소스를 점유하고 있는데, 프로세스 B가 리소스를 빼앗을 수 없어야 합니다. 
- 3. 점유와 대기 : 어떤 프로세스가 리소스 A를 가지고 있는 상태에서 리소스 B를 원하는 상태여야합니다.
- 4. 원형 대기 : 점유와 대기를 하는 프로세스들의 관계가 원형을 이루고 있어야 합니다.

### 데드락이 일어나지 않게 만드는 방법
><교착상태 처리 방법 분류>
1. 교착상태가 절대 생기지 않도록 보장
	- 교착상태 예방, 회피
2. 교착상태가 되도록 허용, 다음에 복구
	- 교착상태 탐지, 회복
3. 교착상태 무시

- 1. 교착상태 예방 : 교착 상태를 발생하는 4가지 조건 중에 적어도 하나가 일어나지 않게 보장함으로써 교착 상태를 예방
	
    (1) 상호배제
      	- 공유 가능한 자원들의 배타적 접근(한 순간에 하나의 스레드or프로세스만 접근)을 요구하지 않는다.
      	- 예를 들어, 읽기 전용 파일에 대해서는 배타적 접근이 필요하지 않는다. 
    
    (2) 점유와 대기
        - 프로세스가 자원을 요청할 때마다 다른 자원을 점유하지 않았음을 보장한다.
        - 방법 1) 프로세스가 실행 시작 전에 필요한 모든 자원을 요청하여 모두 할당 받는다.
        	=> 낮은 자원 이용률을 야기한다.
        - 방법 2) 프로세스가 아무 자원도 점유하고 있지 않을 때만 자원을 요청한다.
        	=> 순차적 자원 할당이 이뤄진다. 기아 발생할 수 있다.
    
    (3) 비선점
        - 한 개 이상의 자원을 점유한 프로세스가 즉시 할당받을 수 없는 추가의 자원을 요청한다면, 현재 잡고 있는 모든 자원을 내려놓는다.
        - 선점된 자원은 기다리고 있는 프로세스를 위한 자원 목록에 추가된다.
        - 프로세스는 요청했던 새로운 자원뿐만 아니라 이전에 소유했던 자원까지 모두 다시 얻었을 때, 다시 시작된다.
        - CPU 레지스터, 메모리 등 그 상태가 저장/복원 가능한 경우에 사용되나, 프린터처럼 자원을 얻고 푸는 행위는 비용이 크기 때문에 적합하지 않다.
    
    (4) 순환 대기
        - 모든 자원 타입들에 대해 전체적으로 순서를 부여한다.
        - 각 프로세스는 오름차순으로만 자원을 요청할 수 있다.
        - 사이클이 발생하지 않으므로 교착상태가 발생하지 않으나, 오름차순 요청은 자원을 활용하는데 큰 제약 조건이 된다.
        
    <교착상태 예방의 단점>
        - 교착상태 예방에서 발생하는 부작용이 크다.
        - 낮은 장치 사용률
        - 감소된 시스템 처리량
- 2. 교착상태 회피
  각 스레드가 자신이 필요로 하는 각 유형의 자원마다 최대 수를 선언하도록 요구하는 것
  각 스레드가 요청할 각 유형의 자원의 최대 수 정보를 미리 파악할 수 있다면, 시스템이 교착 상태에 들어가지 않을 것을 보장한다.
  (1) 안전 상태
  	- 시스템 상태가 안전하다는 말은 시스템이 어떤 순서로든 스레드들이 요청하는 모든 자원을 교착 상태를 야기시키지 않고 차례로 모두 할당해 줄 수 있다는 것을 뜻한다.
    ![](https://velog.velcdn.com/images/hyeop29/post/2cedf50e-9221-47fb-9ac3-1b00370d644d/image.png)
    
   (2) 자원 할당 그래프
  	- 자원 유형마다 하나의 인스턴스를 가지는 경우, 예약 간선 도입
    _설명 추가 예정_
  
   (3) 은행원 알고리즘
   _설명 추가 예정_
   
- 3. 교착상태 탐지
   (1) 대기 그래프
    시스템의 프로세스와 리소스 간의 종속성을 나타내는 방향성 그래프를 구성하는 교착 상태 감지 기술입니다. 이 방법은 교착 상태가 있음을 나타내는 프로세스 간의 순환 종속성을 식별하는 데 도움이 됩니다.
   
   (2) 탐지 알고리즘
   교착 상태를 식별하고 해결하는 데 도움이 될 수 있지만 자원 집약적일 수 있으며 모든 시스템에 적합하지 않을 수 있습니다. 또한 본질적으로 반응적이어서 교착 상태가 발생한 후에만 교착 상태를 해결하므로 성능이 저하될 수 있습니다.
   
   
- 4. 교착상태 회복
   (1) 운영자에 의한 해결
   교착상태 발생을 운영자에게 알리고, 운영자가 교착상태를 수작업으로 처리한다.
   오늘날의 컴퓨터 시스템에서는 비현실적 방법
   
   (2) 프로세스 종료
   교착상태 프로세스를 모두 중지 => 확실하게 교착상태의 사이클을 제거하나, 비용이 많이 든다.
   교착상태가 제거될 때까지 하나씩 중지 => 중지되는 프로세스 수는 줄일 수 있으나, 중지 후 문제가 해결되었는지 확인을 위해 교착상태 탐지 알고리즘을 계속 호출해야 하는 오버헤드 발생
   
   (3) 자원 선점
   교착상태가 깨질 때까지 프로세스로부터 자원을 선점해 다른 프로세스에게 준다.
   <자원 선점의 세 가지 요소>
   ![](https://velog.velcdn.com/images/hyeop29/post/27c5c9c0-a0d9-4030-8f5e-1c8670a262b2/image.png)

- 5. 교착상태를 무시
   Linux와 Windows를 포함해 대부분의 운영체제가 사용하는 방법
   교착 상태를 무시하는 것이 다른 처리 방법과 비교해 비용이 적게 든다.
   많은 시스템에서 교착 상태는 드물게 발생하기 때문에 교착 상태 처리에 대한 부가적인 비용은 그만한 가치가 없다.
   교착 상태를 처리하는 프로그램을 작성하는 것은 개발자의 몫
   
### 코드적으로 예방하는 방법
- 위에서 설명한 교착상태 회피 방법과 교착상태 탐지 및 복구 방법이 코드적으로 예방하는 방법입니다.

### 왜 현대 OS는 데드락을 처리하지 않을까요?
- 교착 상태를 무시하는 것이 다른 처리 방법과 비교해 비용이 적게 듭니다.
  많은 시스템에서 교착 상태는 드물게 발생하기 때문에 교착 상태 처리에 대한 부가적인 비용은 그만한 가치가 없기 때문입니다.
  그러므로, 교착 상태를 처리하는 프로그램을 작성하는 것은 개발자 몫이다.
  
  _"챗지피티는 운영체제에서 데드락을 예방하고 대처한다고 하는데 이부분은 더 찾아봐야겠다"_

### wait free vs lock free
- wait free
  각 스레드 또는 프로세스가 다른 스레드 또는 프로세스의 진행과 독립적으로 진행되도록 보장합니다.
  각 스레드 또는 프로세스는 다른 스레드 또는 프로세스가 완료될 때까지 기다리지 않고 동작을 완료할 수 있습니다. 
  즉, 각 스레드 또는 프로세스의 진행률은 다른 스레드 또는 프로세스의 진행률과 독립적입니다.
  대기 없는 알고리즘은 일반적으로 응답 시간을 예측하고 보장해야 하는 고성능 실시간 시스템에 사용됩니다.

- lock free
  wait free 알고리즘보다 진행에 대한 보장이 약하다. 
  각 스레드나 프로세스는 다른 스레드나 프로세스에 의해 차단되지 않고 동작을 완료할 수 있지만, 모든 스레드나 프로세스가 다른 스레드나 프로세스와 독립적으로 진행된다는 것은 보장되지 않는다. 즉, 일부 스레드 또는 프로세스가 일시적으로 차단될 수 있지만 결국 모든 스레드 또는 프로세스가 진행됩니다. 
  일반적으로 응답 시간의 예측 가능성보다 시스템의 성능이 더 중요한 상황에서 사용됩니다.

---
## 시스템 콜은 무엇인가요?

### 시스템 콜이란  
- 사용자나 응용프로그램이 커널에서 제공하는 기능을 사용하기 위한 인터페이스입니다. 운영체제는 커널에서 제공하는 서비스를 시스템을 이용하여 제한함으로써 컴퓨터 자원을 보호합니다.  

### Syscall이 여러개 있는데 어떻게 찾아가나?
- 각 시스템 콜에는 번호가 할당되고 시스템 콜 인터페이스는 시스템 콜 번호와 시스템 콜 핸들러 함수 주소로 구성되는 시스템 콜 테이블을 유지한다.
- 운영체제는 자신의 커널 영역에서 해당 인덱스가 가리키는 주소에 저장되어 있는 루틴을 수행한다.
- 작업이 완료되면 CPU에게 인터럽트를 발생시켜 수행이 완료 되었음을 알린다.

### Syscall의 매개 변수
필요한 기능이나 시스템 환경에 따라 System Call 이 발생할 때 좀 더 많은 정보가 필요할 수 있다. 그러한 정보가 담긴 매개변수를 운영체제에 전달하기 위해서는 대략 3가지 정도의 방법이 있습니다.  
1. 레지스터를 통한 전송 - 매개변수를 CPU 레지스터 내에 전달한다. 이 경우에 매개변수의 갯수가 CPU 내의 총 레지스터 개수보다 많을 수 있다.
2. 블록 or 테이블을 통한 전송 - 매개변수를 메모리 내의 블록이나 테이블에 저장하고 해당 메모리의 주소가 레지스터에 전달된다.
3. 스택을 통한 전송 - 매개변수는 프로그램에 의해 스택(stack)으로 전달(push) 될 수도 있다.

### 우리가 사용하는 시스템 콜의 예시
1. 라이브러리 함수(printf)를 호출한다.
2. 라이브러리 함수 내부에서 시스템 콜(write)를 호출한다.
3. 해당 시스템 콜의 인덱스(4)를 CPU 레지스터에 저장한다.
4. 0x80 인터럽트를 발생시킨다.(커널 모드로 전환)
5. IDT(Interrupt Descriptor Table)를 참조하여 system_call()을 호출한다.
6. 이때 3에서 저장한 인덱스를 system_call() 함수 내에 전달한다. 
7. sys_call_table을 참조해 해당 인덱스에 맞는 기능(sys_write)을 호출한다. 
8. 수행이 모두 끝나면 사용자 모드로 전환된다.

### 시스템 콜 종류
1. 프로세스 제어
2. 파일 조작
3. 장치 관리
4. 정보 유지
5. 통신
6. 보호


### 운영체제의 Dual Mode 에 대해 설명해 주세요
이중 동작 모드는 쉽게 말해 운영체제를 보호하기 위한 기법이다. 알다시피, 사용자와 운영체제는 시스템 자원을 공유한다. 그렇기 때문에, 사용자에게 제한을 두지 않으면 사용자가 메모리 내의 주요 운영체제 자원을 망가뜨릴 위험이 생기게 된다. 즉, 운영체제의 원활한 작동과 기능을 위해서는 사용자의 시스템 자원 접근을 제한하는 보호 장치가 필수불가결하다. 이러한 보호 장치가 바로 이중 동작 모드(dual-mode operation)이다.


### 서로 다른 시스템 콜을 어떻게 구분할수 있는지?

추가적인 매게변수가 필요하다
1. 매개변수를 레지스터에 담는다.
하지만, 매개변수가 레지스터의 수 보다 많은 경우가 존재하므로 적합하지 않은 방법이다.
2. 매개변수를 연속적 (블록) 또는 불연속적 (테이블 사용)으로 메모리에 담은 뒤, 주소를 레지스터에 담는다.
크기에 제한이 없으므로 많이 사용된다.
3. 스택에 매개변수를 담는다.
이 경우, 스택에 담긴 모든 데이터를 레지스터에 옮기고 스택에 원소를 담아야 하기 때문에, 결과적으로 첫 번째 방법과 큰 차이가 없다.

### 시스템 콜과 함수호출의 차이
시스템 콜  
커널 자원을 사용자가 사용할 수 있도록 만들어 놓은 함수들이며 호출 시 커널 모드로 전환이 되어 실행된다. 리턴 타입은 대부분 int이고 오류는 -1, 정상은 0 이상의 값을 반환한다.

라이브러리 함수  
문자열/표준 입출력 등 사용자가 많이 사용하는 기능들을 미리 함수로 만들어 놓은 것이며 내부적으로 시스템 콜을 사용하지만 호출 시 사용자 모드에서 실행된다. 목적에 따라 다양한 타입의 리턴 값을 갖으며 개발을 쉽게 만들거나 시스템 콜 호출을 최소화하기 위해 제공된다.

### 인터럽트와 시스템 콜의 차이
인터럽트(Interrupt)는 하드웨어가 시스템의 수행 흐름을 바꾸기 위해 CPU를 일시적으로 멈추는 것이다.  
시스템 콜은 OS의 서비스들을 사용 가능하게 해주는 인터페이스들을 제공한다. 

---
## 동기와 비동기, 블로킹과 논블로킹의 차이에대해 설명해주세요


