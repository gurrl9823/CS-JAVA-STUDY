## Hash

#### Hash Function

#### Resolve Collision

#### Open Addressing

#### Separate Chaining

#### Resize

#### 해시 자료구조와, 값 충돌 발생시 처리하는 방법에 대해 설명해 주세요.

#### 본인이 사용하는 언어에서는, 어떤 방식으로 해시 충돌을 처리하나요?

#### 값이 주어졌을 때, 어떻게 하면 충돌이 최대한 적은 해시 함수를 설계할 수 있을까요?

#### 해시값이 충돌했을 때, 어떤 방식으로 처리할 수 있을까요?

#### Double Hashing 의 장점과 단점에 대해서 설명하고, 단점을 어떻게 해결할 수 있을지 설명해 주세요.

#### HashMap 동작 방식에 대해서 설명하세요

---

## 정렬

#### 정렬 알고리즘에 대해 설명해 보세요.

- 정렬 알고리즘은 데이터를 특정한 기준에 따라 순서대로 나열하는 알고리즘입니다.

- - 버블 정렬(Bubble Sort): 인접한 두 원소를 비교하여 순서를 바꾸는 방식으로 동작합니다. 원소의 개수가 작을 때나 이미 정렬되어 있는 경우에만 유용하며, 시간 복잡도는 O(N^2)입니다.

- - 선택 정렬(Selection Sort): 가장 작은/큰 원소를 찾아 정렬되지 않은 부분과 교환하는 방식으로 동작합니다. 원소의 개수가 작을 때나 이미 정렬되어 있는 경우에만 유용하며, 시간 복잡도는 O(N^2)입니다.

- - 삽입 정렬(Insertion Sort): 현재 원소를 이미 정렬된 부분에 삽입하는 방식으로 동작합니다. 원소의 개수가 작고 거의 정렬되어 있을 때 유용하며, 시간 복잡도는 O(N^2)입니다.

- - 퀵 정렬(Quick Sort): 피벗(pivot)을 기준으로 배열을 분할하여 재귀적으로 정렬하는 방식으로 동작합니다. 평균적으로 빠른 속도를 가지며, 시간 복잡도는 평균적으로 O(N log N)입니다. 하지만 최악의 경우에는 O(N^2)의 시간 복잡도를 가질 수 있습니다.

- - 병합 정렬(Merge Sort): 배열을 반으로 나누어 재귀적으로 정렬한 뒤, 병합하여 정렬하는 방식으로 동작합니다. 항상 O(N log N)의 시간 복잡도를 가지며, 추가적인 메모리 공간이 필요하다는 단점이 있습니다.

- - 기수 정렬(Radix Sort): 원소들을 특정한 자리수에 따라 정렬하는 방식으로 동작합니다. 원소의 자리수가 고정되어 있을 때 유용하며, 시간 복잡도는 O(dN)입니다. (d는 가장 큰 자리수)

#### Quick Sort와 Merge Sort를 비교해 주세요.

- Quick Sort: 분할 정복(Divide and Conquer) 알고리즘으로, 피벗(pivot)이라는 기준 원소를 선택하여 배열을 분할하고, 재귀적으로 정렬하는 방식입니다. 평균적으로 빠른 속도를 가지며, 대부분의 경우에 효율적으로 동작합니다. 하지만 최악의 경우(피벗이 항상 최솟값이나 최댓값인 경우)에는 O(N^2)의 시간 복잡도를 가질 수 있습니다.
- Merge Sort: 분할 정복 알고리즘으로, 배열을 반으로 나누어 재귀적으로 정렬한 뒤, 병합(merge)하여 정렬하는 방식입니다. 항상 O(N log N)의 시간 복잡도를 가지며, 안정적인 성능을 보입니다. 하지만 추가적인 메모리 공간이 필요하다는 단점이 있습니다.

#### Quick Sort에서 O(N^2)이 걸리는 예시를 들고, 이를 개선할 수 있는 방법에 대해 설명해 주세요.

- Quick Sort의 최악의 경우는 피벗이 항상 최솟값이나 최댓값인 경우입니다. 이 경우에는 배열이 한쪽으로 치우쳐 분할되어, 시간 복잡도가 O(N^2)이 될 수 있습니다. 이를 개선하기 위해서는 피벗을 잘 선택하는 것이 중요합니다. 예를 들어, 랜덤한 위치의 원소를 피벗으로 선택하거나, 세 개의 원소를 비교하여 중간값(median)을 피벗으로 선택하는 방법 등이 있습니다.

#### Stable Sort가 무엇이고, 어떤 정렬 알고리즘이 Stable 한지 설명해 주세요.

- Stable Sort: 동일한 값의 원소들이 정렬 후에도 원래의 상대적인 순서를 유지하는 정렬 알고리즘을 말합니다. 예를 들어, 동일한 값을 가진 원소들 중에서 먼저 입력된 원소가 먼저 정렬되는 경우가 있습니다.
- Merge Sort가 Stable Sort입니다. Merge Sort는 병합 과정에서 같은 값들을 비교하여 정렬하기 때문에, 동일한 값의 원소들이 정렬 후에도 원래의 순서를 유지합니다.

#### Merge Sort를 재귀를 사용하지 않고 구현할 수 있을까요?

- Merge Sort는 재귀적으로 배열을 반으로 나누어 정렬하는 방식이 특징이기 때문에, 재귀를 사용하지 않고 구현하기는 어렵습니다. Merge Sort의 주요 로직은 배열을 반으로 나누고, 나눈 부분 배열을 병합하는 과정인데, 이를 재귀 없이 구현하려면 반복문 등의 다른 방법을 사용해야 합니다. 그러나 재귀를 사용하지 않는 Merge Sort는 일반적으로 복잡하고 가독성이 낮아지므로, 일반적으로 재귀를 사용하여 구현됩니다.

#### Radix Sort에 대해 설명해 주세요.

- Radix Sort는 원소들을 특정한 자리수에 따라 정렬하는 알고리즘입니다. 주로 정수나 문자열과 같은 비교 가능한 데이터에 사용됩니다. Radix Sort는 각 자리수를 기준으로 정렬하며, 자리수 별로 계수 정렬(Counting Sort)을 사용하여 정렬을 수행합니다. 계수 정렬의 특성상 안정적인 정렬 알고리즘이기 때문에 Radix Sort도 안정적인 정렬 알고리즘입니다. Radix Sort는 원소의 자리수가 고정되어 있을 때 유용하며, 시간 복잡도는 O(dN)입니다. 여기서 d는 가장 큰 자리수입니다.

#### Bubble, Selection, Insertion Sort의 속도를 비교해 주세요.

- Bubble Sort, Selection Sort, Insertion Sort는 모두 비교 기반의 정렬 알고리즘으로, 배열을 비교하고 교환하는 과정을 반복하여 정렬을 수행합니다. 그 중에서는 Bubble Sort가 가장 비효율적이고 느리며, 최선, 평균, 최악의 시간 복잡도 모두 O(N^2)입니다. Selection Sort와 Insertion Sort의 시간 복잡도 역시 최선, 평균, 최악 모두 O(N^2)입니다. 따라서 데이터의 크기가 크고 정렬되어 있지 않은 경우에는 이들 알고리즘보다 더 효율적인 다른 정렬 알고리즘을 선택하는 것이 좋습니다.

#### 값이 **거의** 정렬되어 있거나, 아예 정렬되어 있다면, 위 세 알고리즘의 성능 비교 결과는 달라질까요?

- 이들 알고리즘은 이미 정렬된 부분에 대해 거의 비교와 교환을 하지 않기 때문에, 값이 거의 정렬되어 있거나 정렬되어 있는 경우에는 비교적 빠르게 동작할 수 있습니다. 그러나 여전히 Insertion Sort가 이들보다 성능이 더 좋을 가능성이 있습니다.

#### 본인이 사용하고 있는 언어에선, 어떤 정렬 알고리즘을 사용하여 정렬 함수를 제공하고 있을까요?

- Python에서는 내장 함수인 sorted()와 list.sort()를 사용하여 Tim Sort 알고리즘을 기반으로 한 정렬을 제공하고 있습니다. Java에서는 Arrays.sort()를 사용하여 Dual Pivot Quick Sort와 Merge Sort를 혼합한 알고리즘을 제공하고 있습니다.

#### 정렬해야 하는 데이터는 50G 인데, 메모리가 4G라면, 어떤 방식으로 정렬을 진행할 수 있을까요?

- 정렬해야 하는 데이터가 50G이고, 사용 가능한 메모리가 4G인 경우에는 외부 정렬(External Sort)이라는 기법을 사용하여 정렬을 진행할 수 있습니다. 외부 정렬은 대용량의 데이터를 정렬하기 위해 메모리 외부의 저장 공간을 활용하는 기법으로, 일반적으로 디스크에 저장된 데이터를 메모리에 로드하여 처리하는 방식을 사용합니다. 예를 들면, 대표적인 외부 정렬 알고리즘으로는 Merge Sort와 Polyphase Merge Sort가 있습니다. 이들 알고리즘은 디스크에 저장된 데이터를 여러 번에 걸쳐 정렬하고 병합하는 방식으로 동작하여 대용량 데이터의 정렬을 가능케 합니다.

#### Quick Sort와 Merge Sort를 비교해 주세요

- 평균 시간 복잡도

Quick Sort: O(n log n) - 평균적으로 가장 빠른 정렬 알고리즘 중 하나로 알려져 있습니다.
Merge Sort: O(n log n) - Quick Sort와 동일한 평균 시간 복잡도를 가지고 있습니다.

- 최악 시간 복잡도

Quick Sort: O(n^2) - 이미 정렬된 배열과 같이 Pivot 값에 따라 분할이 한쪽으로 치우칠 경우 최악의 경우 시간 복잡도가 저하될 수 있습니다.
Merge Sort: O(n log n) - 최악의 경우에도 일정한 성능을 유지합니다.

- 공간 복잡도

Quick Sort: O(log n) - Quick Sort는 In-place Quick Sort와 같이 추가적인 메모리를 사용하지 않는 In-place 알고리즘이 존재하지만, 대부분의 경우 추가적인 메모리가 필요합니다.
Merge Sort: O(n) - Merge Sort는 별도의 추가적인 메모리를 사용하여 분할된 배열을 병합하는 과정에서 O(n)의 추가 메모리 공간이 필요합니다.

- 안정성

Quick Sort: 불안정 정렬(Unstable Sort) - Pivot 값에 따라서 데이터가 교환되는 과정에서 순서가 뒤섞일 수 있습니다.
Merge Sort: 안정 정렬(Stable Sort) - 동일한 값에 대해 순서를 유지하여 정렬됩니다.

- 최적화 가능성

Quick Sort: Pivot 선택과 분할 방법을 최적화할 수 있는 여지가 있어, 빠른 실행을 위해 최적화가 가능합니다.
Merge Sort: 병합 과정에서 추가적인 최적화가 어렵기 때문에, Quick Sort와 비교했을 때 최적화가 상대적으로 어려울 수 있습니다.

#### Radix Sort에 대해 설명해주세요.

- Radix Sort(기수 정렬)은 비교 기반 정렬 알고리즘이 아닌, 자릿수를 기준으로 정렬하는 정렬 알고리즘입니다. 숫자의 각 자릿수를 개별적으로 비교하여 정렬하는 특징이 있어, 정수나 문자열과 같은 데이터를 정렬하는 데에 효과적입니다.
- Radix Sort는 기수(radix)라는 개념을 사용하여 정렬을 수행합니다. 기수는 각 자릿수의 범위를 나타내는데, 예를 들어 10진수의 경우 기수는 0부터 9까지의 값을 가집니다. Radix Sort는 각 자릿수를 순차적으로 비교하며 정렬을 수행합니다.

---

## 재귀함수

#### 재귀함수에 대해 설명해 주세요.

#### 재귀 함수의 동작 과정을 Call Stack을 활용해서 설명해 주세요.

#### 언어의 스펙에 따라, 재귀함수의 최적화를 진행해주는 경우가 있습니다. 어떤 경우에 재귀함수의 최적화가 가능하며, 이를 어떻게 최적화 할 수 있을지 설명해 주세요

#### 재귀 함수의 최적화 방법을 설명해 보세요.

#### 주로 사용하는 언어에서 꼬리재귀최적화를 지원하는 지

#### ARC

---

## DP

#### Dynamic Programming이란? 장점은?

- Dynamic Programming(동적 계획법)은 최적화 문제를 해결하는 알고리즘 기법 중 하나로, 부분 문제의 최적 해답을 계산하고, 이를 활용하여 전체 문제의 최적 해답을 찾는 방식입니다.
- Dynamic Programming은 중복되는 부분 문제들을 중복 계산하지 않고 한 번만 계산하여 효율적으로 최적해를 구하는 장점이 있습니다.

#### 피보나치를 통한 재귀와 DP를 비교하여 설명해보세요

- 피보나치 수열을 통한 재귀와 Dynamic Programming을 비교하면, 재귀 방식은 중복되는 계산이 많아 효율성이 떨어집니다.
- 예를 들어, 피보나치 수열에서 f(5)를 계산하기 위해서 f(4)와 f(3)을 각각 계산하는데, f(4)를 계산할 때에도 f(3)과 f(2)를 중복해서 계산하게 됩니다.
- 이에 비해, Dynamic Programming을 활용한 방식에서는 중복 계산을 피하고 한 번 계산한 결과를 저장하여 재활용하여 효율적으로 피보나치 수열을 계산할 수 있습니다.

#### 그리디 알고리즘과 동적 계획법에 대해 설명하고, 어떤 경우에 각각의 기법을 사용할 수 있는지 설명해 주세요.

- 그리디 알고리즘(Greedy Algorithm)은 최적해를 찾기 위해 매 순간마다 그 순간에 가장 좋은 선택을 하는 알고리즘입니다.
- 그리디 알고리즘은 간단하고 빠르게 구현할 수 있으며, 일부 문제에서 최적해를 보장할 수 있습니다.
- 그러나 그리디 알고리즘은 항상 최적해를 찾는 것이 보장되지 않는 경우가 있으며, 이를 사용할 수 있는 문제의 범위가 제한적입니다.
- 동적 계획법은 부분 문제의 최적해를 계산하여 전체 문제의 최적해를 구하는 방식으로, 최적 부분 구조와 중복된 부분 문제를 갖는 문제들에 효과적입니다.
- 동적 계획법은 중복 계산을 피하고, 부분 문제의 최적해를 저장하여 재활용하므로, 최적해를 보장하고 효율적으로 문제를 해결할 수 있습니다.

#### 그렇다면, 어떤 경우에 각각의 기법을 사용할 수 있을까요?

- 그리디 알고리즘
- - 최적 부분 구조(Optimal Substructure)와 탐욕적 선택 속성(Greedy Choice Property)이 만족될 때 효과적으로 사용할 수 있습니다.
- - 각 단계에서 현재 상황에서 가장 최선의 선택을 하는 것으로 문제를 해결합니다.
    대표적인 예시로는 최소 신장 트리(Minimum Spanning Tree), 최단 경로(Shortest Path), 탐욕적 압축(Greedy Compression) 등이 있습니다.
    그리디 알고리즘은 간단하고 빠른 속도로 문제를 해결할 수 있지만, 항상 최적해를 보장하지는 않습니다.
- 동적 계획법
- - 부분 문제들의 최적해를 저장하고 재활용하여 문제를 해결하는 방식으로, 중복 계산을 피하고 효율적으로 최적해를 찾을 때 사용할 수 있습니다.
    부분 문제들이 겹치는 경우, 부분 문제의 최적해를 한 번만 계산하고 이를 저장하여 효율적으로 문제를 해결합니다.
    대표적인 예시로는 피보나치 수열, 최장 공통 부분 수열(Longest Common Subsequence), 배낭 문제(Knapsack Problem) 등이 있습니다.
- - 동적 계획법은 최적 부분 구조와 중복 계산이 있는 경우에 효과적이며, 최적해를 보장합니다. 그러나 메모리 사용량이 크고 구현이 복잡할 수 있습니다.

#### 그렇다면, 동적 계획법으로 풀 수 있는 모든 문제는 재귀로 변환하여 풀 수 있나요?

- 동적 계획법은 부분 문제의 최적해를 저장하고 재활용하기 위해 메모리를 사용하는데, 이를 "메모이제이션(Memoization)"이라고 합니다. 일반적으로 재귀 함수는 함수 호출 시마다 스택 메모리를 사용하며, 메모이제이션을 구현하기 위해서는 저장할 공간을 할당하고 관리해야 합니다. 이는 모든 문제에 대해 항상 가능하지 않을 수 있습니다. 또한, 일부 문제는 동적 계획법의 접근 방식 자체를 재귀로 변환하기 어렵거나 비효율적일 수 있습니다.
- 따라서, 동적 계획법으로 풀 수 있는 문제를 재귀로 변환하여 풀 수 있는지는 문제의 특성과 구현의 효율성에 따라 다를 수 있습니다. 일부 문제는 재귀로 풀기보다는 동적 계획법으로 구현하는 것이 효율적이고 실용적일 수 있습니다. 그러나, 일부 문제는 재귀로 구현하는 것이 간결하고 이해하기 쉬울 수 있습니다. 따라서, 문제의 특성과 구현의 효율성을 고려하여 적절한 방법을 선택하는 것이 중요합니다.

---

## The Other

- MST가 무엇이고, 어떻게 구할 수 있을지 설명해 주세요.

#### Kruskal 알고리즘에서 사용하는 Union-Find 자료구조에 대해 설명해 주세요.

#### Kruskal 과 Prim 중, 어떤 것이 더 빠를까요?

- Trie, KMP, Rabin Karp, Boyer Moore 알고리즘을 비교해 주세요

#### 문자열을 저장하고, 처리하는 주요 자료구조 및 알고리즘 (Trie, KMP, Rabin Karp 등) 에 대해 설명해 주세요.

- 최단거리 알고리즘에 대해 설명하고, 각각의 차이를 설명해 주세요.

#### floyd-warshall

#### bellman-ford

#### 실제로는 어떤 알고리즘 사용?
