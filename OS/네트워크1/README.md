## TCP

#### 3-way Handshake 에 대해 설명해 주세요.

#### ACK, SYN 어디에 저장하나?

#### 2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.

#### 두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?

#### SYN Flooding 에 대해 설명해 주세요.

#### 4-way Handshake 에 대해 설명해 주세요

#### 패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?

#### 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?

#### 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?

#### 패킷에 담겨진 헤더 정보?

#### 연결을 끊는다고 어떤 쪽에서 보낼 때, 더 이상 정보를 보내지 않도록 통제하는 방법?

#### 왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요?

---

## HTTP

#### HTTP에 대해 설명해주세요

- HTTP (Hypertext Transfer Protocol)는 웹에서 데이터를 전송하기 위해 사용되는 프로토콜로, 클라이언트와 서버 간의 통신을 담당합니다. 여러 가지 버전과 확장이 있으며, 보안을 강화한 HTTPS (HTTP Secure)도 있습니다.

#### 공개키와 대칭키에 대해 설명해 주세요.

- 공개키 (Public Key): 암호화와 복호화에 사용되는 서로 다른 키를 가진 암호화 방식입니다. 공개키는 공개되어 있어 누구나 알 수 있고, 클라이언트와 서버 간의 통신에서 서버가 클라이언트에게 전달됩니다.
- 대칭키 (Symmetric Key): 암호화와 복호화에 동일한 키를 사용하는 암호화 방식으로, 키의 유출에 노출되어 있기 때문에 보안성이 낮은 단점이 있습니다.

#### 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?

- HTTPS는 HTTP의 보안 버전으로, 데이터를 암호화하여 안전한 통신을 제공합니다. HTTPS Handshake 과정에서는 클라이언트와 서버 간에 인증서가 교환됩니다. 인증서는 서버의 신원을 확인하고, 클라이언트가 서버와 안전한 통신을 수행할 수 있도록 공개키를 제공합니다.

#### SSL과 TLS의 차이는 무엇인가요

- SSL (Secure Socket Layer)과 TLS (Transport Layer Security)은 둘 다 암호화 프로토콜로, HTTPS에서 사용됩니다. SSL은 오래된 버전이며 현재는 사용되지 않습니다. TLS는 SSL의 후속 버전으로 보안 강화와 개선이 이루어진 버전입니다.

#### HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?

- HOL Problem (Head-of-Line Blocking): HTTP/1.1에서는 여러 개의 요청이 동시에 전송되더라도 응답이 도착한 순서대로 처리되어, 하나의 응답이 끝나기 전에 다른 응답이 대기해야 하는 문제가 있습니다. 이를 HOL Problem이라고 합니다.
- HTTP/1.0 vs HTTP/1.1: HTTP/1.0은 각 요청마다 새로운 연결을 맺어야 했지만, HTTP/1.1에서는 지속적인 연결(Persistent Connection)을 지원하여 연결을 유지하고 다수의 요청과 응답을 처리할 수 있습니다.

#### HOL Problem

- HOL Problem (Head-of-Line Blocking): HOL Problem은 HTTP/1.1에서 발생하는 문제로, 여러 개의 요청이 동시에 전송되더라도 응답이 도착한 순서대로 처리되어, 하나의 응답이 끝나기 전에 다른 응답이 대기해야 하는 현상을 말합니다. 이로 인해 효율성이 저하되고, 성능이 떨어질 수 있습니다.

#### HTTP/1.0 vs HTTP/1.1

- HTTP/1.0은 각 요청마다 새로운 연결을 맺어야 했기 때문에 연결의 오버헤드가 높았습니다. 또한, 지속적인 연결(Persistent Connection)을 지원하지 않아 매번 연결을 새로 맺어야 했습니다.
- HTTP/1.1은 지속적인 연결을 지원하여 연결을 유지하고 다수의 요청과 응답을 처리할 수 있습니다. 또한, 요청/응답 헤더의 압축, 파이프라이닝(Pipelining) 등의 기능을 도입하여 성능을 향상시켰습니다.

#### HTTP/3.0

- HTTP/3.0은 QUIC(Quick UDP Internet Connections) 프로토콜을 기반으로 한 버전으로, 기존의 TCP를 사용하는 HTTP/1.1과 HTTP/2와 달리, UDP를 사용하여 보다 빠르고 안정적인 데이터 전송을 지원합니다. QUIC은 패킷 손실이나 네트워크 변화에 더 잘 대응할 수 있어, 성능이 향상됩니다. 또한, HOL Problem을 완화하고 멀티플렉싱(Multiplexing) 기능을 지원하여 동시에 여러 개의 요청과 응답을 처리할 수 있도록 합니다.

#### HTTP 프로토콜의 특징

- Stateless: HTTP는 Stateless 프로토콜로, 클라이언트와 서버 간의 각 요청과 응답이 독립적으로 처리됩니다. 이는 클라이언트가 이전의 요청과 상태 정보를 서버에 저장하지 않고, 모든 정보를 요청마다 전송하여 처리하는 특징입니다.
- Connectionless: HTTP는 Connectionless 프로토콜로, 클라이언트와 서버 간의 연결을 유지하지 않고 각 요청마다 새로운 연결을 맺습니다. 요청과 응답이 한 번 이루어지면 연결이 종료되는 특징을 가지고 있습니다.

#### HTTPS에 대해 설명해주세요

- HTTPS는 HTTP 프로토콜의 보안 버전으로, HTTP 통신을 암호화하여 보안성을 강화한 프로토콜입니다. HTTPS는 SSL(Secure Socket Layer) 또는 TLS(Transport Layer Security) 프로토콜을 사용하여 통신 내용을 암호화하고, 서버의 신원을 인증하는 인증서를 사용합니다.

#### 인증서를 사용하는 이유?

- 인증서는 서버의 신원을 인증하는 역할을 합니다. 클라이언트가 서버와 통신을 할 때, 서버의 인증서를 확인하여 신뢰성과 보안성을 보장할 수 있습니다. 인증서를 사용하여 서버의 신원을 검증하고, 중간자 공격과 같은 보안 위협을 방지할 수 있습니다.

#### 공개키, 대칭키 장단점

- 공개키: 공개키 암호화 방식은 공개키와 개인키를 사용하여 데이터를 암호화하고 복호화하는 방식입니다. 장점으로는 보안성이 높아 개인키를 보호하면 안전하게 통신할 수 있다는 점이 있습니다. 단점으로는 암호화와 복호화 과정에서의 연산이 복잡하고 느리다는 점이 있습니다.
- 대칭키: 대칭키 암호화 방식은 동일한 키를 암호화와 복호화에 사용하는 방식으로, 빠르게 데이터를 암호화하고 복호화할 수 있는 장점이 있습니다. 단점으로는 키를 안전하게 공유해야 한다는 점이 있습니다.

#### Stateless와 Connectionless에 대해 설명해 주세요.

- Stateless: Stateless는 각 요청과 응답이 독립적으로 처리되는 특징을 말합니다. HTTP는 클라이언트와 서버 간의 상태 정보를 저장하지 않고, 모든 요청이 독립적으로 처리됩니다. 클라이언트가 이전 요청과 상태를 서버에 저장하지 않기 때문에 서버의 부하를 줄이고, 확장성을 향상시킬 수 있습니다.
- Connectionless: Connectionless는 클라이언트와 서버 간의 연결을 유지하지 않고 각 요청마다 새로운 연결을 맺는 특징을 말합니다. HTTP는 각 요청마다 새로운 연결을 맺고 요청에 대한 응답을 받은 후에 연결을 종료합니다. 이는 서버의 자원을 효율적으로 관리할 수 있고, 다수의 클라이언트와 연결을 처리할 수 있는 장점을 가지고 있습니다.

#### 왜 HTTP는 Stateless 구조를 채택하고 있을까요?

- Stateless 구조를 채택한 이유는 서버의 부하를 줄이고, 확장성을 향상시키기 위함입니다. 클라이언트와 서버 간의 상태 정보를 저장하지 않고 독립적으로 처리함으로써 서버의 자원을 효율적으로 관리하고, 다수의 클라이언트와 연결을 처리할 수 있습니다.

#### HTTP Persistence Connection

- HTTP Persistence Connection은 연결을 유지하는 기능으로, HTTP/1.1부터 도입된 기능입니다. 연결을 유지하면 여러 요청과 응답을 하나의 연결로 처리할 수 있어, 연결을 맺고 끊는 과정의 오버헤드를 줄여 속도를 향상시킬 수 있습니다.

#### 왜 HTTP는 Stateless 구조를 채택하고 있을까요?

- 서버의 부하를 줄이기 위함: HTTP는 각 요청과 응답이 독립적으로 처리되는 Stateless 특징을 가지고 있습니다. 이는 서버가 클라이언트의 이전 요청과 상태를 저장할 필요가 없다는 것을 의미합니다. 서버는 각 요청에 대한 응답을 처리한 후에 해당 연결을 종료하거나, 상태 정보를 저장하지 않고 다음 요청을 처리합니다. 이로써 서버의 부하를 줄일 수 있고, 서버의 자원을 효율적으로 관리할 수 있습니다.
- 확장성을 향상시키기 위함: Stateless 구조는 서버가 상태 정보를 저장하지 않고 각 요청을 독립적으로 처리하기 때문에, 다수의 클라이언트와 연결을 처리하거나 서버를 확장하는 데 유리합니다. 서버는 클라이언트와의 연결을 유지하지 않고 각 요청을 독립적으로 처리하므로, 서버의 확장성을 높일 수 있습니다.
- 서버와 클라이언트 간의 의존성을 낮추는 장점: 서버가 클라이언트의 상태를 저장하지 않고 요청을 처리하기 때문에, 클라이언트가 어떤 상태를 갖고 있는지에 대한 의존성이 낮아집니다. 이는 서버와 클라이언트 간의 느슨한 결합을 가능하게 하며, 시스템의 유연성과 확장성을 높일 수 있습니다.

#### HTTP Persistence Connection 이 무엇인가요?

- HTTP Persistence Connection은 연결을 유지하는 기능으로, HTTP/1.1부터 도입된 기능입니다. 연결을 유지하면 여러 요청과 응답을 하나의 연결로 처리할 수 있어, 연결을 맺고 끊는 과정의 오버헤드를 줄여 속도를 향상시킬 수 있습니다.

#### TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요

- TCP의 keep-alive: TCP의 keep-alive는 TCP 연결을 유지하면서 통신이 없는 경우에도 연결을 유지하는 기능입니다. TCP 연결을 끊지 않고 유지하면, 다음 통신 시에 연결을 다시 맺지 않아도 되어 효율적인 통신이 가능합니다.
- HTTP의 keep-alive: HTTP의 keep-alive는 하나의 연결을 통해 여러 요청과 응답을 처리하는 기능입니다. 연결을 유지하면서 다수의 요청과 응답을 처리할 수 있어, 연결을 맺고 끊는 과정의 오버헤드를 줄이고 속도를 향상시킬 수 있습니다.

#### GET과 POST의 차이점은 무엇인가요?

- 데이터 전달 방식: GET은 URL에 데이터를 포함하여 요청을 전달하고, POST는 요청의 Body에 데이터를 포함하여 전달합니다. GET은 URL에 데이터가 노출되므로 보안에 취약할 수 있습니다. 반면 POST는 요청의 Body에 데이터를 포함하여 전달하기 때문에, 데이터의 노출이 적어보안성이 높습니다.
- 캐싱: GET은 데이터를 캐싱할 수 있으며, 같은 요청에 대한 응답이 캐시에서 가져와서 처리될 수 있습니다. POST는 요청이나 응답이 캐시되지 않고, 항상 서버에 전달되어 처리되어야 합니다.
- 데이터 길이 제한: GET은 URL에 데이터를 포함하기 때문에 데이터 길이에 제한이 있습니다. 반면 POST는 요청의 Body에 데이터를 포함하기 때문에 데이터 길이에 제한이 없습니다.

#### Get with body / 안쓰는 이유

- HTTP 프로토콜에서는 일반적으로 GET 요청에는 요청의 Body에 데이터를 포함하지 않습니다. 이는 GET 요청의 목적이 리소스를 조회하는 것이고, 서버의 상태를 변경하지 않는다는 Stateless 원칙에 따른 것입니다.

- GET 요청에도 Body에 데이터를 포함할 수는 있지만, 이는 일반적인 사용 방법이 아닙니다. 왜냐하면 많은 웹 서버와 프록시 서버가 GET 요청의 Body를 무시하거나, 잘못 처리할 수 있기 때문입니다. 또한, GET 요청의 Body에 데이터를 포함하는 경우에는 데이터가 URL에 노출되지 않고, 보안적인 측면에서 안전하지 않을 수 있습니다.

- 따라서, GET 요청은 주로 리소스를 조회하는 용도로 사용되고, 요청의 Body에 데이터를 포함하는 것은 권장되지 않습니다. 만약 서버의 상태를 변경해야 하는 경우에는 POST, PUT, PATCH 등의 다른 HTTP 메소드를 사용하는 것이 더 적합합니다.

#### POST vs PUT, PATCH

- POST는 새로운 리소스를 생성하기 위해 사용되는 메소드입니다. PUT은 기존의 리소스를 수정하기 위해 사용되는 메소드이며, 해당 리소스가 없으면 새로 생성됩니다. PATCH는 리소스의 일부분만 수정하기 위해 사용되는 메소드입니다.
- 요청의 내용: POST는 요청의 Body에 새로운 데이터를 전달하여 리소스를 생성합니다. PUT은 요청의 Body에 전체 리소스를 전달하여 해당 리소스를 수정하거나 생성합니다. PATCH는 요청의 Body에 일부분만 변경하고자 하는 데이터를 전달합니다.

#### HTTP Method 에 대해 설명해 주세요.

- GET: 리소스를 조회하기 위해 사용되는 메소드로, 서버에서 클라이언트에게 데이터를 반환합니다.
- POST: 새로운 리소스를 생성하기 위해 사용되는 메소드로, 서버에 데이터를 전송하여 리소스를 생성합니다.
- PUT: 기존의 리소스를 수정하기 위해 사용되는 메소드로, 서버에 데이터를 전송하여 리소스를 수정하거나 생성합니다.
- PATCH: 리소스의 일부분만 수정하기 위해 사용되는 메소드로, 서버에 데이터를 전송하여 리소스의 일부분을 수정합니다.
- DELETE: 리소스를 삭제하기 위해 사용되는 메소드로, 서버에게 리소스를 삭제하도록 요청합니다.

#### 멱등성에 대해 설명해주세요.

- 멱등성은 동일한 요청을 여러 번 수행하더라도 결과가 동일하게 유지되는 특성을 말합니다. HTTP 프로토콜에서는 멱등성을 가진 메소드들이 존재합니다.

#### HTTP Method의 멱등성에 대해 설명해 주세요.

- HTTP 메소드의 멱등성은 해당 메소드를 여러 번 수행하더라도 서버의 상태가 변하지 않고, 동일한 리소스에 대한 요청이라면 항상 동일한 응답이 반환되는 특성을 의미합니다. 예를 들어, GET 메소드는 리소스를 조회하는 용도로 사용되며, 서버의 상태를 변경하지 않으므로 멱등성을 가집니다.

#### GET과 POST의 차이는 무엇인가요?

- GET 메소드는 리소스를 조회하는 용도로 사용되며, 서버로부터 정보를 요청하는 데 사용됩니다. POST 메소드는 클라이언트가 서버에게 데이터를 전송하여 리소스를 생성하거나 서버의 상태를 변경하는 데 사용됩니다. 따라서, GET과 POST의 가장 큰 차이는 요청의 목적과 성격에 있습니다.

#### POST와 PUT, PATCH의 차이는 무엇인가요?

- POST: 서버에게 새로운 리소스를 생성하라는 요청입니다. 리소스의 위치는 서버가 자동으로 생성하며, 여러 번 요청하더라도 같은 리소스를 중복해서 생성하지 않도록 구현되어야 합니다. 멱등성을 보장하지 않습니다.
- PUT: 클라이언트가 명시적으로 리소스의 위치를 지정하여 리소스를 수정하라는 요청입니다. 이미 해당 위치에 리소스가 존재하면 수정되고, 존재하지 않으면 새로운 리소스가 생성됩니다. 멱등성을 가지며, 동일한 요청을 여러 번 수행하더라도 같은 결과가 유지됩니다.
- PATCH: 리소스의 일부를 수정하라는 요청입니다. PUT과 유사하게 리소스를 수정하지만, 리소스의 일부만을 수정하므로 요청의 결과가 서로 다를 수 있습니다. 멱등성을 가지지 않습니다.

#### HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?

- GET은 주로 리소스를 조회하는 용도로 사용되는 메소드로, 서버의 상태를 변경하지 않아야 하는 Stateless 원칙에 따라야 합니다. 따라서 GET 메소드에 Body에 데이터를 실어서 요청하는 것은 RESTful API 디자인 원칙과 맞지 않습니다. GET 메소드는 서버에서 리소스를 가져오는 용도로만 사용되어야 합니다.
- GET 요청은 일반적으로 캐싱이 가능하도록 설계되어 있습니다. 하지만 Body에 데이터를 실어서 요청하는 경우에는 캐싱이 어려워지거나 불가능해질 수 있습니다. 캐싱은 네트워크 성능을 향상시키고, 서버의 부하를 줄여줄 수 있는 중요한 기술입니다. 따라서 GET 메소드에 Body에 데이터를 추가하는 것은 캐싱을 제한하고 성능에 부정적인 영향을 미칠 수 있습니다.
- 보안과 개인정보의 이슈가 있습니다. GET 요청은 URL에 파라미터가 노출되는 형태로 요청이 이루어지므로, Body에 데이터를 포함하게 되면 URL에 민감한 정보가 노출될 수 있습니다. 이는 보안과 개인정보 보호에 취약점을 남길 수 있습니다.

#### HTTP 응답코드에 대해 설명해주세요.

- 401 (Unauthorized): 클라이언트가 인증되지 않은 상태로 요청을 보낸 경우 사용되는 응답코드입니다. 클라이언트가 인증을 통해 자격 증명을 제공하면 요청이 허가될 수 있습니다.
- 403 (Forbidden): 클라이언트가 요청한 리소스에 대한 접근 권한이 없는 경우 사용되는 응답코드입니다. 인증은 되었지만, 해당 리소스에 대한 권한이 없는 경우에 반환됩니다.
- 200 (OK): 요청이 성공적으로 처리되었음을 나타내는 응답코드입니다. 요청한 작업이 성공적으로 완료되어 클라이언트에게 요청한 리소스의 내용이나 상태가 반환됩니다.
- 201 (Created): 요청이 성공적으로 처리되었고, 새로운 리소스가 생성되었음을 나타내는 응답코드입니다. 일반적으로 POST 요청에 사용되어 새로운 리소스가 성공적으로 생성되었음을 클라이언트에게 알려줍니다.

#### 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?

- 401 (Unauthorized)은 인증이 필요한 상태를 나타내며, 403 (Forbidden)은 권한이 없는 상태를 나타냅니다. 401은 클라이언트가 인증을 통해 접근할 수 있는 가능성이 있지만, 403은 접근 자체가 허용되지 않은 상태를 의미합니다.
- 예: 401은 로그인에 실패한 상태, 403은 로그인에는 성공했으나 권한이 없는 것을 요청한 상태

#### 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.

- 200 (OK)는 클라이언트의 요청이 성공적으로 처리되었고, 서버가 클라이언트에게 요청한 데이터나 리소스를 제공함을 나타냅니다. 이 응답코드는 주로 GET 요청에 사용되며, 요청된 데이터가 성공적으로 반환되었음을 의미합니다.

- 201 (Created)은 클라이언트의 요청이 성공적으로 처리되었고, 서버가 새로운 리소스를 생성하였음을 나타냅니다. 이 응답코드는 주로 POST 요청에 사용되며, 요청된 리소스가 성공적으로 생성되었음을 의미합니다. 서버는 생성된 리소스의 URI를 응답 헤더에 포함하여 클라이언트에게 알려줄 수 있습니다.

#### pre-defined 가 안 된 status code?

- Pre-defined되지 않은 HTTP 상태 코드도 사용될 수 있습니다. 하지만, 이러한 사용은 표준화되지 않아서 특정 애플리케이션 또는 서비스에서만 사용되며 일반적으로 권장되지 않습니다. 표준 HTTP 상태 코드를 사용하는 것이 인터넷 상에서 일관성을 유지하고, 이해하기 쉽고, 호환성이 높기 때문에 권장됩니다.

#### HTTP와 HTTPS

- HTTP와 HTTPS는 둘 다 인터넷 상에서 정보를 전송하기 위한 프로토콜입니다. 그러나 HTTP는 평문(Plain text)으로 데이터를 전송하는 반면에, HTTPS는 SSL(Secure Socket Layer) 또는 TLS(Transport Layer Security) 암호화 프로토콜을 사용하여 데이터를 암호화하여 보안성을 강화한 프로토콜입니다. 따라서 HTTPS는 보안이 요구되는 경우에 사용되며, 개인정보, 금융정보, 로그인 정보와 같은 민감한 데이터를 전송할 때 사용됩니다.

#### HTTP 요청/응답 헤더

- HTTP 요청/응답 헤더는 HTTP 프로토콜에서 클라이언트와 서버 간에 전송되는 메타 정보입니다. 요청 헤더는 클라이언트가 서버에게 요청을 보낼 때 요청의 속성이나 설정을 전달하며, 응답 헤더는 서버가 클라이언트에게 응답을 보낼 때 응답의 속성이나 설정을 전달합니다. 이러한 헤더는 키-값 쌍으로 이루어져 있으며, HTTP 요청 또는 응답의 시작 부분에 위치하며, 다양한 헤더 필드가 포함될 수 있습니다.
- 요청 헤더에는 다양한 정보가 포함될 수 있습니다. 예를 들면, 요청 메서드(GET, POST, PUT, DELETE 등), 요청 URI(Uniform Resource Identifier), 호스트 이름, 사용자 에이전트 정보, 콘텐츠 타입, 인증 정보, 캐시 제어 정보, 사용 언어 등이 포함될 수 있습니다. 이러한 요청 헤더는 클라이언트가 서버에게 요청을 보낼 때 요청의 속성이나 설정을 전달하여 서버가 요청을 올바르게 처리할 수 있도록 합니다.
- 응답 헤더에는 다양한 정보가 포함될 수 있습니다. 예를 들면, 응답 상태 코드(200, 201, 404, 등), 콘텐츠 타입, 캐시 제어 정보, 인증 정보, 서버 정보 등이 포함될 수 있습니다. 이러한 응답 헤더는 서버가 클라이언트에게 응답을 보낼 때 응답의 속성이나 설정을 전달하여 클라이언트가 응답을 올바르게 처리하고 필요한 정보를 획득할 수 있도록 합니다.

#### HTTP와 HTTPS 동작 과정

- HTTP의 동작 과정

클라이언트(웹 브라우저)가 서버에게 HTTP 요청을 보냅니다. 이 요청은 평문(Plain text)으로 전송됩니다.
서버는 클라이언트의 요청을 받고, 요청에 대한 처리를 수행한 후, HTTP 응답을 생성하여 클라이언트에게 전송합니다. 이 응답 역시 평문으로 전송됩니다.
클라이언트는 서버로부터 받은 HTTP 응답을 해석하여 요청에 따른 처리를 수행합니다.

- HTTPS의 동작 과정

클라이언트(웹 브라우저)가 서버에게 HTTPS 요청을 보냅니다. 이 요청은 암호화되어 전송됩니다.
서버는 클라이언트의 요청을 받고, 서버의 디지털 인증서를 클라이언트에게 제공합니다. 이 인증서는 서버의 공개키를 포함하고 있습니다.
클라이언트는 서버의 인증서를 확인하고, 서버의 공개키를 사용하여 요청 데이터를 암호화하여 서버에게 전송합니다.
서버는 클라이언트로부터 받은 암호화된 요청 데이터를 복호화하여 처리합니다.
서버는 HTTP 응답을 생성하여 클라이언트에게 전송합니다. 이 응답은 암호화되어 전송됩니다.
클라이언트는 서버로부터 받은 암호화된 HTTP 응답을 복호화하여 요청에 따른 처리를 수행합니다.

---

## UDP

#### TCP와 UDP의 차이점은 무엇인가요?

#### HTTP 에서 TCP를 고집하였던 이유 / HTTP/3.0에서는 왜 UDP(QUIC)를 사용하는가?

#### checksum

#### TCP / UDP 헤더 차이

#### UDP의 실시간 스트리밍 외 다른 예시

#### TCP 연결에 혼잡제어나 flow control 동작 방식

#### TCP 핸드쉐이크

#### 왜 HTTP는 TCP를 사용하나요?

#### 그렇다면, 왜 HTTP/3 에서는 UDP(QUIC) 를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?

#### 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?

#### TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?

#### 그렇다면, Checksum을 통해 오류를 정정할 수 있나요?

#### TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.

#### TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.

---

## OSI 7계층

#### OSI 7계층에 대해 설명해 주세요.

#### Transport Layer 의 역할, 예시

#### TCP, UDP 헤더의 특징

#### 인터넷 4계층

#### L3 Switch / Router

#### 각각의 Header의 Packing Order

#### 3계층 프로토콜 → 왜 IP만 이야기할까?

#### ICMP

#### ARP

#### L3 Switch와 Router의 차이에 대해 설명해 주세요.

#### 각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.

#### 각각의 Header의 Packing Order에 대해 설명해 주세요.

---

## CORS

#### CORS(Cross Origin Resource Sharing)란

#### CORS 동작원리

#### CORS 과정

#### Socket.io와 WebSocket의 차이

#### Frame Packet Segment Datagram
