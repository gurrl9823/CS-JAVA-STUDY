## 접근 제한자

#### static class와 static method를 비교해 주세요.
static class
- 클래스 안에 있는 내부 클래스.
- 외부 클래스를 정적 클래스로 만들 수 없지만 내부 클래스를 정적 클래스로 만들 수 있다.
- 정적 내부 클래스는 외부 클래스의 비 정적 멤버에 액세스 할 수 없다.
- 정적 클래스는 인스턴스화 될 수 없다. 따라서 정적 클래스 내부의 메서드는 정적 클래스 이름으로 직접 액세스 할 수 있다.

static method
- 메소드에 static을 붙이면 변수와 마찬가지로 인스턴스를 생성하지 않고 바로 호출할 수 있다. 
- 스태틱 메소드는 보통 유틸리티성 메소드를 작성할 때 많이 사용된다. 예를 들면 StringUtils.isEmpty() 와 같이 StringUtils 인스턴스를 만들지 않고 메소드를 바로 사용할 수 있다.


#### static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?
- 2가지 이점이 있다. 
- 첫번째는 항상 동일한 값을 가지는 변수의 경우 static으로 선언하지 않으면 같은 값을 가지는 변수 여러개가 만들어지지만 stataic으로 선언하면 메모리에 한번만 할당되어 메모리 사용 측면에서 이점이 된다. 
- 두번째는 변수를 공유한다는 것이다. 예를 들어 인스턴스를 만들 때마다 count를 1씩 증가시키는 코드를 짰다면 해당 변수를 static으로 선언해서 인스턴스가 생성될 때마다 동일한 변수를 사용하여 count를 하게 된다.


#### 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.
- static 변수는 앱이 실행될 때 메모리 할당이 이루어지고, non-static 변수는 인스턴스 생성 시 메모리에 할당된다.

#### non-static 멤버와 static 멤버의 차이
- 변수를 공유하는지 안하는지 차이가 있다. 변수를 static으로 선언하면 프로그램 실행 시 메모리에 할당되고 어디서 접근하든 해당 변수를 공유한다. static으로 선언하지 않으면 인스턴스를 여러개 많들었을 시에 그 변수는 각자의 메모리를 가진 별개의 변수가 된다.


---

## JVM & Garbage collections

#### JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.
- Java Byte Code를 OS에 맞게 해석 해주는 역할을 합니다. Java compiler는 .java 파일을 .class 라는 Java byte code로 변환 시켜 줍니다. Byte Code 는 기계어가 아니기 때문에OS에서 바로 실행되지 않습니다. 이때 JVM은 OS가 ByteCode를 이해할 수 있도록 해석 해줍니다. 그로인해 Byte Code는 JVM 위에서 OS상관없이 실행할 수 있습니다.

#### 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?
- 자바 이외의 Kotlin 등의 언어는 JVM 위에 올릴 수 있습니다.
하지만 C, C++ 소스코드는 컴파일 시 목적 코드인 기계어로 변하게 되고 java는 자바 컴파일러(javac.exe)를 이용하여 JVM이 이해할 수 있는 중간단계의 언어인 바이트 코드(.class)로 변하게 되기 때문에  C++ 코드를 직접 JVM에서 실행하는 것은 불가능 합니다.

#### 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
- 특정 하드웨어가 아닌 가상 컴퓨터(Virtual Machine)에서 돌아가는 실행 프로그램을 위한 이진 표현법으로 하드웨어가 아닌 소프트웨어에 의해 처리되기에 기계어보다 추상적이어서 안됩니다.

#### VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
- 장점
1. 플랫폼 독립성입니다. JVM은 운영체제나 하드웨어와 상관없이 동일한 바이트 코드를 실행할 수 있기 때문에, 자바 프로그램의 플랫폼 독립성을 보장합니다.
2. 메모리 관리입니다. JVM은 개발자가 명시적으로 메모리를 해제하는 번거로움을 줄이고, 메모리 누수를 방지하여 프로그램의 안정성과 성능을 향상시킵니다.
3. 예외 처리입니다. JVM은 자바 프로그램이 실행 중에 발생하는 예외를 처리하여, 비정상적으로 종료되는 것을 방지할 수 있습니다.
4. 다양한 자바 라이브러리 사용할 수 있도록 지원합니다.

- 단점
1. 먼저 바이트 코드를 해석하고 실행하는 과정에서 성능 손실이 발생할 수 있습니다.
2. 프로그램 실행에 필요한 메모리를 동적으로 할당하고 해제하기 때문에, 일부 시스템에서는 메모리 사용량이 부담스러울 수 있습니다.
#### JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
- JVM은 운영체제 위에서 실행되는 프로그램이며, 내부에서는 스레드(thread)라는 개념을 사용하여 동시에 여러 작업을 처리할 수 있습니다. 따라서, 부모 프로세스 - 자식 프로세스 관계와는 다릅니다.

스레드는 프로세스 내부에서 실행되는 실행 단위로, 한 프로세스 내에서 여러 스레드를 생성하여 동시에 여러 작업을 처리할 수 있습니다. 이러한 스레드는 자원 공유를 통해 프로세스 내부의 다른 스레드와 통신하며, 이를 통해 효율적인 작업 처리가 가능해집니다.

따라서, JVM과 내부에서 실행되는 프로그램은 부모 프로세스-자식 프로세스 관계를 갖는 것이 아니라, 단일 프로세스 내에서 스레드를 통해 동시에 작업을 처리하는 구조입니다.

#### 자바가 컴파일 되는 과정을 설명해주세요
1. 개발자가 자바 소스코드(.java)를 작성합니다.
2. 자바 컴파일러(Java Compiler)가 자바 소스파일을 컴파일합니다.
3. 컴파일된 바이트 코드를 JVM의 클래스로더(Class Loader)에게 전달합니다.
4. 클래스 로더는 JVM 메모리에 바이트 코드들을 올려줍니다.
5. 실행엔진(Execution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행합니다.

#### Java의 GC에 대해 설명해 주세요.
- 가비지 컬렉션(Garbage Collection, 이하 GC)은 자바의 메모리 관리 방법 중의 하나로 JVM(자바 가상 머신)의 Heap 영역에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거하는 프로세스를 말한다
(프로그램에서 더 이상 사용하지 않는 객체를 자동으로 해제하여, 메모리를 회수하는 기능)
#### finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?

#### 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?
- 값이 null인 변수는 해당 변수가 참조하던 객체를 더 이상 참조하지 않기 때문에, GC의 대상이 될 수 있습니다. 하지만, 값이 null인 변수가 GC의 대상이 될 수 있는지 여부는 해당 변수를 참조하는 다른 변수나 객체의 참조 상황에 따라 달라질 수 있습니다. GC가 수행되는 시점에서 해당 변수가 더 이상 참조되지 않는다면, GC의 대상이 될 수 있습니다.

---

## 객체 지향 특성

#### 추상화, 캡슐화, 상속이란

#### 인터페이스와 추상클래스의 차이 (Interface VS Abstract Class)

#### interface와 abstract에 대해서 설명하세요.

#### 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?

#### 다형성이란

#### Overriding vs Overloading

#### 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.

#### 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?

#### 객체 지향 프로그래밍이란 (객체 지향 개발 원칙은 )

#### SOLID원칙에 대해서 설명하세요

#### 객체지향언어가 절차지향언어와 다르게 가지는 장점은 무엇인가요?

---

## 자료형

#### 불변 객체가 무엇인지 설명하고 대표적인 Java의 예시를 설명해주세요.
- 불변객체(immutable object)는 생성 후 그 상태를 바꿀 수 없는 객체를 말합니다. 
Java에서는 필드가 원시 타입인 경우 final 키워드를 사용해 불변 객체를 만들 수 있습니다.

#### 참조 타입일 경우 추가적인 작업은 어떤게 있는지 설명해주세요
1. 참조 변수가 일반 객체인 경우 객체를 사용하는 필드의 참조 변수도 불변 객체로 변경해야 합니다.

2. 배열일 경우 배열을 받아 copy해서 저장하고, getter를 clone으로 반환하도록 하면 됩니다.

3. 리스트인 경우에도 배열과 마찬가지로 생성시 새로운 List를 만들어 값을 복사하도록 해야 합니다.


#### 불변 객체나 final을 굳이 사용해야 하는 이유가 있을까요?
1. 공유 자원이 불변이기 때문에 항상 동일한 값을 반환하기 때문에 동기화를 고려하지 않아도 된다
2. 어떠한 예외가 발생되더라도 메소드 호출 전의 상태를 유지할 수 있어 예외 발생 전과 똑같은 상태로 다음 로직 처리 가능)

3. 부수효과를 피해 오류를 최소화 할 수 있다.
※ 부수효과 : 변수의 값이 바뀌거나 객체의 필드 값을 설정하거나 예외나 오류가 발생하여 실행이 중단되는 현상

4. 메소드 호출 시 파라미터 값이 변하지 않는다는 것을 보장할 수 있다.

5. 가비지 컬렉션 성능을 높일 수 있다.

(가비지 컬렉터가 스캔하는 객체의 수가 줄기 때문에 Gc 수행 시 지연시간도 줄어든다.)
#### Call by Reference와 Call by Value 의 차이
- Call by Value 
메소드를 호출할 때 넘겨 주고 싶은 인자를 지정하면, 메소드의 매개 변수가 지정한 변수 값의 복사본으로 초기화되는 것이다.
따라서 함수 내에서의 변경은 메소드를 호출할 때 지정한 변수(원본)에 아무 영향을 미치지 않는다.

- Call by Reference
메소드를 호출할 때 넘겨 주고 싶은 인자를 지정하면, 메소드의 매개 변수가 지정한 변수의 레퍼런스로 초기화되는 것이다.
따라서 함수 내에서의 변경은 메소드를 호출할 때 지정한 변수(원본)에 영향을 받아 바뀌어집니다.

#### 제네릭(Generic)이란
- 자바 프로그래밍에서 타입 안정성을 보장하기 위한 기능입니다. 제네릭을 사용하면 컴파일 시에 타입 체크를 할 수 있고, 잘못된 타입 사용으로 인한 런타임 오류를 방지할 수 있습니다
#### 제네릭 처리 방법

#### Boxing/unboxing
- 자동 박싱은 기본 타입을 래퍼 클래스로 자동으로 변환하는 것이고, 자동 언박싱은 래퍼 클래스를 기본 타입으로 자동으로 변환하는 것입니다.
#### String & StringBuffer & StringBuilder
- String, StringBuffer, StringBuilder는 자바에서 문자열을 다루는 클래스입니다
- String은 문자열 연산이 적고, 불변성과 스레드 안전성이 필요한 경우에 주로 사용됩니다. 
- StringBuffer는 문자열 연산이 많고, 스레드 간의 안전한 동시 접근이 필요한 경우에 사용됩니다. 
- StringBuilder는 문자열 연산이 많고, 단일 스레드 환경에서 사용되며 동기화 문제로 인해 스레드 안전성이 요구되지 않는 경우에 사용됩니다.
#### equals()와 hashcode()에 대해 설명해 주세요.
- equals
보통 2개의 객체가 가리키는 곳이 동일한 메모리 주소일 경우에만 동등한 객체가 되지만 String 클래스에서 equals 메소드를 오버라이드하여 객체가 같은 값을 갖는지 동등성(Equality)을 비교해주어 2개의 객체가 동일한지 판단할 수 있습니다.

- 해쉬코드
객체의 주소값(int)을 이용하여 객체 고유의 해시코드를 리턴하는 함수입니다. 또 해쉬코드는 객체를 식별하는 정수값으로, 객체가 저장되는 해시 테이블이나 해시 기반의 자료 구조에서 빠른 검색을 위해 사용됩니다


#### new String()과 리터럴("")의 차이에 대해 설명해주세요.
- new String()과 리터럴("")의 차이는 문자열 객체의 생성 방식과 동작 방식에 있습니다 new String()은 매번 새로운 객체를 생성하므로 메모리에 추가 객체가 할당됩니다.
리터럴("")은 문자열 풀에서 이미 존재하는 동일한 문자열을 재사용하므로 객체의 재사용이 가능한 차이가 있습니다.
#### final 키워드를 사용하면, 어떤 이점이 있나요?
- final로 선언된 변수는 값을 변경할 수 없는 불변성과
재할당되지 않으므로, 중요한 값들을 보호할 수 있는 보안과
final로 선언된 변수는 컴파일 시점에 값을 결정하므로, 실행 시간에 추가적인 검색 또는 계산을 수행하지 않아도 되는 성능의 최적화 이점이 있습니다.
#### final 키워드 (final/finally/finalize)
- final (변수, 메서드, 클래스에 적용 가능)
- finally try-catch 문에서 예외 처리 코드의 일부
- finalize 객체 소멸 전에 리소스의 해제, 마무리 작업 등을 수행할 수 있도록 제공되는 객체 소멸 전에 호출되는 메서드입니다.

#### 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
- 컴파일 과정에서 final 키워드는 다르게 취급되지 않습니다. final 키워드는 컴파일러에 의해 해당하는 변수, 메서드, 클래스에 대한 제한을 적용하는 용도로 사용되며 문법 검사 및 최적화를 수행하기 위한 용도로 사용됩니다

---

## 클래스, 생성자

#### 클래스와 객체에 대해 설명해주세요.

#### 클래스 멤버 변수 초기화 순서

#### 생성자(Constructor)에 대해 설명해주세요.

#### Inner Class(내부 클래스)의 장점에 대해 설명해주세요.

#### 리플렉션(Reflection)이란 무엇인지 설명해주세요.

#### 리플렉션은 어떤 경우에 사용되는지 설명해주세요.

#### 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?

#### 리플렉션을 언제 활용할 수 있을까요?

#### Java Collections Framework
